---
title: "Week 02, Day 02"
output: html_notebook
---

# Matrices and Lists

- Know what lists and matrices are.
- Know how to create lists and matrices.
- Be able to do some basic manipulations on lists and matrices.

What data structures have we seen so far?

- vectors
- dataframes (tibbles)

vectors are one-dimensional (they Grow in one direction)
vectors are homogenous (they can only have one datatype)

dataframes are two-dimensional
dataframes are heterogenous

```{r}
different_types <- c(1L, 2.0, "freddy")

class(different_types)
```

```{r}

# What type of object is (x)?
#?class(x)
```

Lists are one-dimensional and heterogenous
matrices are two-dimensional and homogenous


```{r}
# can make lists with list() or as.list()
first_list <- list("a", 34, c(1, 2, 3), TRUE)

list_different_types <- as.list(different_types)
```

access the value 2 from first list

```{r}
different_types[3]

# single square brackets return the same class of object
first_list[3]
first_list[[3]][2]
```

We can also access things by name, if they are named

```{r}
named_vector <- c(
  first = 1,
  second = 2
)

# not run
recode(x, "1" = 1.1)
left_join(x, y, by = c("x.id" = "y.x_id"))

named_list <- list(
  vector = named_vector,
  list = first_list
)

# access vectors by name
named_vector["first"]

#again, get the value 2 from the named list
named_list[["vector"]]

named_list$list[[3]][2]
```
Task - 5 minutes
Make a named list that contains a numeric vector and a character vector.

Access the second element of your list using double square brackets
[[]]. What is its class?
Access the second element of your list using single square brackets []. What is its class?
Access the second element of your list by name. What is its class?

```{r}
named_list <- list(
  num_vector = c(1, 2, 3),
  char_list = c("A", "B", "C")
)

named_list[[2]]
```

---
title: "Week 02, Day 02"
output: html_notebook
---

# Matrices and Lists

- Know what lists and matrices are.
- Know how to create lists and matrices.
- Be able to do some basic manipulations on lists and matrices.

What data structures have we seen so far?

- vectors
- dataframes (tibbles)

vectors are one-dimensional (they Grow in one direction)
vectors are homogenous (they can only have one datatype)

dataframes are two-dimensional
dataframes are heterogenous

```{r}
different_types <- c(1L, 2.0, "freddy")

class(different_types)
```

```{r}

# What type of object is (x)?
#?class(x)
```

Lists are one-dimensional and heterogenous
matrices are two-dimensional and homogenous


```{r}
# can make lists with list() or as.list()
first_list <- list("a", 34, c(1, 2, 3), TRUE)

list_different_types <- as.list(different_types)
```

access the value 2 from first list

```{r}
different_types[3]

# single square brackets return the same class of object
first_list[3]
first_list[[3]][2]
```

We can also access things by name, if they are named

```{r}
named_vector <- c(
  first = 1,
  second = 2
)

# not run
recode(x, "1" = 1.1)
left_join(x, y, by = c("x.id" = "y.x_id"))

named_list <- list(
  vector = named_vector,
  list = first_list
)

# access vectors by name
named_vector["first"]

#again, get the value 2 from the named list
named_list[["vector"]]

named_list$list[[3]][2]
```
Task - 5 minutes
Make a named list that contains a numeric vector and a character vector.

Access the second element of your list using double square brackets
[[]]. What is its class?
Access the second element of your list using single square brackets []. What is its class?
Access the second element of your list by name. What is its class?

```{r}
named_list <- list(
  num_vector = c(1, 2, 3),
  char_list = c("A", "B", "C")
)

named_list[[2]]
class(named_list[[2]])

named_list[2]
class(named_list[2])


# access vectors by name
named_list["char_list"]
class(named_list)
```
## 
Fergus Cherry

```{r}
new_list <- list(numeric_vector = c(1, 2, 3), character_vector = c("hi", "a", "b"))
# acces second element return list
new_list[[2]]
class(new_list[[2]])
new_list[2]
class(new_list[2])
new_list$character_vector
class(new_list$character_vector)

#sccess second element return list
new_list["character_vector"]
class(new_list["character_vector"])

# access second element(return vector)
new_list[["character_vector"]]
class(new_list[["character_vector"]])
```

James
```{r}
list_task <- list(numb = c(1, 2, 3), char = c("a", "b", "c"))

list_task[[2]]
class(list_task[[2]])

list_task[2]
class(list_task[2])

list_task["char"]
class(list_task["char"])
```

## Matrices

- like 2d vectors

```{r}
m <- matrix(1:6, nrow = 2, ncol = 3)
m
```
matrices fill default by column ('byrow = TRUE' to fill by row instead)

Acessing elements

Getting rows
Getting columns
Getting cell values

```{r}
m[1, 2] # [row, column]
m[, c(1, 3)] # can grab multiple rows/cols with vectors
```

can do thats with matrices if they are numeric

```{r}
m + 10
m / 6
```
```{r}
# this indexing works on data frames
iris[c(1, 41, 101), 5]
```

Other matrix operations

```{r}
rowSums(m)
colSums(m)

# these also work on data frames not they aren't 'tidy' operations
colSums(is.na(iris))
```

matrix

```{r}
matrix(1:5, nrow = 4, ncol = 3)
```

will we
A) get lots of NA values (it puts in 1,2,3,4,5, NA,NA, NA, ..)
b) error
c) recycling 1,2,3,4,5,12


Task - 5 minutes
Make a matrix with 3 rows and 4 columns. Each column should contain the numbers 1 to 3.

1 1 1 1
2 2 2 2
3 3 3 3

Find the element in the 2nd row, 3rd column.
Check that all the columns are identical by checking that their sums are the same.

```{r}
test_matrix <- matrix(1:3, nrow = 3, ncol = 4)

test_matrix

elt <- test_matrix[2, 3]
elt

colSums(test_matrix)

```
In maths

A           B
 3   7    1
 6   9    2

```{r}
A <- matrix(c(3, 6, 7, 9), nrow = 2)
B <- matrix(1:2, nrow = 2)

```

# Control Flow

## Learning Objectives

- Know the structure of all the conditional statements
- Be able to nest conditional statements
- Know how to use for loops, but understand when they should not be used.

`if`
`else`
`else if`

`return`

If statements

```{r}
some_condition <- FALSE

if (some_condition){
  that()
}
```

```{r}
# has some control flow going on
readr::read_csv
```


some_condition is usually a logical expression

x < 10
names_cols %in% c("q1", "q2", "q3")
is.character(x)

conditions -> particular eventualities

```{r}
x <- 8
y <- 7


if (x > y) {
  print("Yes")
}
```

Task - 5 minutes
Write an if statement that prints ‘Yes that divides by 2’ if a number x is divisible by 2 (hint: use %% 2 == 0 as your expression), try it out for different values of x.

```{r}
x = 0 # result Yes that divides by 2
x = 2 # result Yes that divides by 2
x = 3 # result nothing
x = -2 # result Yes that divides by 2

div_by_two <-  x %% 2 == 0 

if (div_by_two) {
  print("Yes that divides by 2")
}
```

## Nested if statement

```{r}
x <- 10
y <- 2
y <- 3

if (x > y) {
  print("Start of outer if block")

  if (x %% y == 0) {
    print("Inner if block 1")
  }

  if (y %in% c(1:5)) {
    print("Inner if block 2")
  }

  print("End of outer if block")
}

print("After if statement")
```

## if - else logic

```{r}
if (3 %in% 4:6){
  print("Yes")
} else {
  print("No")
}
```

## For Loops

- loops allow you to 'easily' repeat actions/sections of code

For loop

- do it for as many times as I say
for x many times:
  do_y()
  
While loops

- keep doing until some condition is met
until z happens:
  do_y()
  
```{r}
print("The day is Monday")
print("The day is Tuesday")
print("The day is Wednesday")
print("The day is Thursday")
print("The day is Friday")
```
```{r}
# for five times:
# print day

days <- c("Monday", "Tuesday", "Wednesday", "Thursday", 
          "Friday", "Saturday", "Sunday")

# x= bannana variable dont need to name
#for (x in 1:5){
for (day in days){
  # paste adds space by default
  print(paste("The day is", day))
  #print("day")
  #print(x)
}
```
Task 5 mins
Change the code below to use a for loop:
print(1)
print(2)
print(3)
print(4)
print(5)

```{r}
for (x in 1:5){
  print(paste0("print(", x, ")"))
}
```
1:30

# While lops

keep doing some operation until some condition is met

```{r}

stop <- FALSE
counter <- 1

while (!stop){
  print("going")
  counter <- counter + 1
  
  # counter += 1
  if (counter == 5){
    stop <- TRUE
  }
}
```

There is the potential to loop infinitelt. Make sure you have some
' breaking' condition.

We don't know exactly how many things to expect (potential use case)

- maybe getting input at some point (Do you want to continue?)

## Other ways of writing loop indexes

```{r}
weekdays <- c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday", "Charlesday")

# using indices
for (i in 1:length(weekdays)) {
    phrase <- paste("The day is", weekdays[i])
    print(day)
    print(phrase)
    # or could do in one line as
    # print(paste("The day is", day))
} 
```

# Nested Loops

- loops can be useful to iterate over hierarchical data structures
(matrices, dataframes)

# letters is an inbuilt vector
```{r}
m <- matrix(letters[1:9], nrow = 3)
m
```

For every item inthe matrix, print that item and its position e.g.
At position [1, 1] we find: "a"
At position [2, 1] we find: "b"

```{r}
# slower loop
for (col_index in 1:3){
#  print(m[, col_index])
  
  # faster loop
  for (row_index in 1:3){
    value <- m[row_index, col_index]
    phrase <- paste0("At position [", row_index, ",", col_index, "] we find:", value)
    print(phrase)
  }
}
```
Run the code below to create an empty 5×5 matrix:
product_matrix <- matrix(nrow = 5, ncol = 5)

Check that the matrix is empty.

Now we’re going to fill product_matrix in the following way: each entry should be the product of the row index and position index at which the entry occurs. For example, the entry on the third row, fourth column, should be 3×4=12

Get the matrix dimensions programatically (so that we could in the future apply this code to any size of matrix with minimal changes).

```{r}
m[1,1]
```


```{r}
product_matrix <- matrix(nrow = 5, ncol = 5)
product_matrix

#num_rows <- dim(my_matrix)[1]
#num_cols <- dim(my_matrix)[2]


for (row_index in 1:nrow(product_matrix)){
  for (col_index in 1:ncol(product_matrix)){
       value =  row_index * col_index
  #    print (paste("value ", value))
   #   print (paste("row", row_index, " col", col_index))
      product_matrix[row_index, col_index] = value
  }
}

dim(product_matrix)

product_matrix
```

Why do we tend to avoid loops?



Iterate over a vector of integers, convert each element into that +10

1, 2, 3
11, 12,13

```{r}
ints <- 1:3

for (i in 1:length(ints)){
  ints[i] <- ints[i] + 10
}
ints

# automatically applies the operation to element in the vector
ints + 10

ints %% 2 == 0

ifelse(ints == 13, 30, ints)
```

We tend not to write loops to iterate over data structures

```{r}
# start with empty object
my_data <- NULL

#f or every file in data folder
for (file in list.files("data")){
  # read it in
  part_data <- read_csv(file)
  #append it to current state
  my_data <- bind_rows(my_data, part_data)
}

data()
  jan_sales.csv
  feb_sales.csv
  march_sales.csv

```

```{r}
iris <- iris[, c(1, 2, 3, 4)]
iris2 <- iris / 1.1
iris3 <- iris / 1.9

dplyr::bind_rows(
  list(jan_values = iris, 
       feb_values = iris2, 
       march_values = iris3),
       .id = "month"
)

```



```{r}
m1 <- matrix(data = 1:10, nrow = 5, ncol = 6)

# ?apply
sum_cols_m1 <- apply(X = m1, MARGIN = 2, FUN = median)

sum_cols_m1

v <- c()

for (col_index in 1:ncol(m1)){
  v[col_index] <- median(m1[, col_index])
}
```

Another example with lapply and sapply

Use the cars dataset which is built in R. USe each of lapply and sapply()
functions to measure the mean speed and topping distance of the cars
How does the output of each function differ?

```{r}
# Apply a Function over a List or Vector
# returns a list
lapply(cars, mean)

# returns a vector
sapply(cars, FUN = mean)

mean(cars[[1]])
mean(cars[[2]])

apply_function(X = what_to_loop_over,
               FUN = funcion_to_do)
# does function to each thing in X
```
# Functions

# Learning Objectives

- Be able to write your own functions
- Know best practice for writing R functions

A function is an isolated block of code that accepts an input (or inputs) and returns an output. This of it as being like a machine on a production line: unprocessed items go into the machine, processed items come out!

Functions are wee machines that take in something and give out something else. usually the first thing transformed in some way

```{r}
dim(x = iriss)
```

Function arguments

- pass by name
- pass by position


## S3 method for class 'data.frame'
mutate(
  .data,
  ...,
  .by = NULL,
  .keep = c("all", "used", "unused", "none"),
  .before = NULL,
  .after = NULL
)


```{r}
?mutate
dplyr::mutate(
  iris,
  Petal.Ratio = Petal.Length / Petal.Width,
  "used",
  .before = Petal.Length
)
```

... is special. any arguments after ... need to be given by name

## Writing our own functions

```{r}
# = Default argument

function_name <- function(argument_1, argument_2 = value){
  
  # Do something with arguments
  
  return(output)
}
```

```{r}
multiply_by_five <- function(somevalue){
  # last operation of function gets returned without needing return()
  somevalue * 5
}

multiply_by_five(30)

```

giving default arguments

function sope (what can functions see, what can we see about functions?)

best practices

```{r}
mutiply_by_six_default <- function(v1, v2 = 6){
  v1 * v2
}

mutiply_by_six_default(3)
```

```{r}
triangular_number <- function (n)
  triangular = (n * (n + 1)) / 2

print(triangular_number(5))
print(triangular_number(1))
print(triangular_number(10))

```
```{r}
triangular_number <- function(n) {
  return(0.5 * n * (n + 1))
}
```

If you want to output multiple things from a function use a list, named lists are nice.
You can call functions from within functions

dH(n) = 2 * T(n)

```{r}
get_hexagonal_number <- function(n){
  return(2 * triangular_number(n))
}

get_hexagonal_number(4)
```
## Function scope

- what can be seen?

1. by the function
2. of the function

functions can see and do things with anything in your 'global' environment

```{r}
print_favourite_day <- function(days = c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday")){
  
  favourite_day <- days[5]
  return(favourite_day)
}

print_favourite_day()
```
It';'s far better ractice for functions to only use what's in their immediate environment ('local' environment)

What can we see of functions?

-> only what is returned


```{r}
favourite_day <- "Saturday"

if(x %%2 == 0) print("Even")
```

If your write same bit of code three tims usually a combo of multiple operatuibs

e.g. drop columns -> privot

It's time to write a re-usable function

DRY principle - good practice don't repeat yourself. If you make a mistake in repeated code, you'll have ti come back and change every instance of that mistake.


```{r}
triangular_number <- function(n) {
  return(0.5 * n * (n + 1))
}

get_david_hexagonal_number <- function(n) {
  return(2 * trianjular_number(n))
}

get_david_hexagonal_number(4)

# open debugger next time function run
debugonce(get_david_hexagonal_number)

```


```{r}
debugonce()
```

